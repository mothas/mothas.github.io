---
layout: post
title: "Cod[e] Philosophy"
author: "Thomas Alex Mathew"
---

[Cod Philosophy](https://en.wikipedia.org/wiki/Pseudophilosophy){:target="_blank"} is an idea I passively subscribe to. The first time I heard about Cod Philosophy is in a song by one of my favorite bands [Porcupine Tree](https://en.wikipedia.org/wiki/Porcupine_Tree){:target="_blank"}. Cod Philosophy is just another term for Pseudophilosophy. The word Cod is from the word _codswallop_ - not codfish.  Though I'm not a huge fan of formal Philosophy, the term Cod Philosophy struck me early on.

After years of toiling with computers, I have come up with my Cod Philosophy for Software Engineers - **Code Philosophy**. This emerged during conversations I have had with many. I thought I'll write it down before I forget these.

There are 3 principles that makes up Code Philosophy. They are:

* Stay lazy
* Do **not** trust yourself
* Cut the drama

Plain and simple! And seemingly useless. But let me explain why I think it's an important set of principles to adopt.

## Stay lazy
This is a notion that is bound to improve your productivity. There have been many instances when my laziness has forced me to pick up more productive habits.

> If necessity is the mother of invention, then laziness is the father.

When I started off my career, this laziness led me to learn VLOOKUPs on Microsoft Excel (they are the best!). This laziness has stayed with me till date. One of the best things I have learned is Regular Expressions. It was at a time when I had to edit many Cassandra table definitions. A simple "find and replace" didn't help me to edit those table definitions in bulk. I needed a much broader text matching technique. Enter **Regex**. There has never been a better productivity improvement after that.

![Stay Lazy](/assets/gif/lazy_simpson.gif)

So if you aren't "lazy" yet, start cultivating laziness!

## Do not trust yourself

This thought is to improve reliability.

> The path of sound credence is through the thick forest of skepticism.

It can translate to different skills depending on the context. A few examples:
* if you find yourself repeating similar tasks often, automate it using a script. This not only increases your productivity but also reduces the chances of errors.
* use checklists as much as possible. This was helpful when setting up new systems to ensure I didn't miss ANY step.
* when configuring software systems, you would have to edit/write many config-files. If you can avoid typing out ANY config, you've already reduced the chances of making errors. Try to copy and paste configuration from a template as much as possible.

![Do not trust yourself](/assets/gif/i_will_not.gif)

Well, we came up with digital calculators mostly because we did _not_ trust ourselves crunching numbers. Look where that (healthy) skepticism has brought us to.

## Cut the drama

When you are dealing with software, you're bound to face errors. Especially when trying out something new. If these errors are going to frustrate you, itâ€™s hard to progress. In other words, you should embrace errors/bugs as a learning opportunity. Have an open mind.

> Albert Einstein said "It's not that I'm so smart, it's just that I stay with problems longer".

I'm not sure if I agree with Einstein not seeing himself as smart, but I like this quote.

In my current role at [Insight](https://insightfellows.com/){:target="_blank"}, I've seen a stark difference between strong engineers and the rest. It is the sheer ability to wade through an avalanche of errors that makes that difference.

![Cut the drama](/assets/gif/cut_the_drama.gif)

So stay calm and persevere. In fact, you should build an appetite for challenges.

# Summary

Let us summarize the above points.

|Principle   |Ways to act on principle   | Result   |
|---|---|---|
| Stay lazy  | Use shortcuts or tools  | Increase productivity  |
| Do not trust yourself  | Automate or reduce manual processes| Reduce errors  |
| Cut the drama  | Do not panic when you see errors; persevere  | Learn and build new things quickly |


<br>
Let me know what you think about Code Philosophy.
